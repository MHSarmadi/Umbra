# 1.1 – MACE-BLAKE3 Encryption Doc

This document specifies the design, usage, and security considerations for the **MACE-BLAKE3** symmetric encryption core used in Umbra v1.  
It is based on the public MACE design ([github.com/MHSarmadi/MACE](https://github.com/MHSarmadi/MACE)) with Umbra-specific adaptations.

---

## 1. Overview

The MACE-BLAKE3 core is a **chunk-based, round-iterated, symmetric encryption construction** built entirely on the [BLAKE3](https://github.com/BLAKE3-team/BLAKE3) cryptographic hash function.

It supports four main modes:

| Mode           | API Name                                  | Notes |
|----------------|-------------------------------------------|-------|
| Simple         | `MACE_Encrypt` / `MACE_Decrypt`           | No authentication, randomized with salt unless `deterministic = true` |
| MIXIN          | `MACE_Encrypt_MIXIN` / `MACE_Decrypt_MIXIN` | Binds external data into key derivation, not authenticated |
| AEAD           | `MACE_Encrypt_AEAD` / `MACE_Decrypt_AEAD` | Authenticated encryption with 16–32 byte tag |
| MIXIN + AEAD   | `MACE_Encrypt_MIXIN_AEAD` / `MACE_Decrypt_MIXIN_AEAD` | Authenticated encryption, also binds external data into key derivation |

**Core Properties:**
- **KDF**: BLAKE3 `DeriveKey` with versioned context string + key + salt.
- **PRF**: BLAKE3 `Keyed` for block mixing and tag generation.
- **Chunk Size**: 64 bytes (special-case 32 bytes for single-block messages to ensure ≥ 2 chunks).
- **Rounds**: `2*difficulty + 3` — see §5.3 for rationale.
- **Padding**: PKCS#7 with fixed block size of 64 bytes.
- **In-place operation**: Encryption/decryption mutates buffers.

---

## 2. API Summary

### 2.1 Simple
```go
func MACE_Encrypt(key, data []byte, context string, difficulty uint16, deterministic bool) (cipher, salt []byte)
func MACE_Decrypt(key, cipher, salt []byte, context string, difficulty uint16) (raw []byte, err error)
```

* `salt` is 12 random bytes (length is fixed in implementation; v1 uses 12 depending on final choice).
* If `deterministic = true`, salt is all zeros (same inputs → same outputs).
* Padding always applied before encryption.

---

### 2.2 MIXIN

```go
func MACE_Encrypt_MIXIN(key, data, mixin []byte, context string, difficulty uint16, deterministic bool) (cipher, salt []byte)
func MACE_Decrypt_MIXIN(key, cipher, mixin, salt []byte, context string, difficulty uint16) (raw []byte, err error)
```

* `mixin` is hashed with `blake3.Sum512` and appended to the key before KDF.
* Only purpose is to bind extra data into the key schedule.

---

### 2.3 AEAD

```go
func MACE_Encrypt_AEAD(key, data []byte, context string, difficulty uint16, deterministic bool) (cipher, salt, tag []byte)
func MACE_Decrypt_AEAD(key, cipher, salt, tag []byte, context string, difficulty uint16) (raw []byte, valid bool, err error)
```

* Generates authentication tag over `(cipher || difficulty)` using the same derived BLAKE3 key.
* Tag length: **16 bytes**.
* Caller **MUST** check `valid` before using `raw`. The decryption function **ALWAYS** return something, even on failure decryptions.

---

### 2.4 MIXIN + AEAD

```go
func MACE_Encrypt_MIXIN_AEAD(key, data, mixin []byte, context string, difficulty uint16, deterministic bool) (cipher, salt, tag []byte)
func MACE_Decrypt_MIXIN_AEAD(key, cipher, mixin, salt, tag []byte, context string, difficulty uint16) (raw []byte, valid bool, err error)
```

* Same as AEAD but also binds `mixin` into key derivation.
* Tag covers `(cipher || difficulty || mixin)`.

---

## 3. Security Model

MACE-BLAKE3 is **not** a standard cipher or AEAD mode, but is constructed to provide:

* **Confidentiality**: Derived from BLAKE3’s PRF security and block mixing.
* **Integrity (AEAD modes)**: Derived from keyed BLAKE3 MAC over ciphertext + associated fields.
* **Diffusion**: Every chunk influences other chunks across rounds.
* **Key Separation**: KDF ensures separate keys for encryption and MAC.
* **Domain Separation**: Context strings include Umbra version and mode name.

### 3.1 Authentication caveats

* **Simple** and **MIXIN** modes have **no integrity protection**. Use AEAD variants whenever possible.

### 3.2 Deterministic encryption caveats

* If `deterministic = true`, same `(key, context, plaintext[, mixin])` → same ciphertext.
  This leaks message equality and should only be used when intended (e.g., deduplication).

---

## 4. Hazards and Warnings

**IMPORTANT**: See top-of-file hazard block in `encryption.go`.

1. **Always check `valid` before using plaintext** in AEAD modes.
   This implementation returns a dummy or corrupted plaintext even on authentication failure.

2. **Do not assume `MIXIN` is authenticated** — treat it as part of the key, not as AAD.

3. **Salt randomness** is critical for non-deterministic encryption.
   Never reuse `(key, context, salt)` across encryptions.

4. **Buffers are mutated** — copy inputs if you need to preserve them.

5. **Padding output** on failure may still look valid length-wise — always check `err` from decryptors.

---

## 5. Internal Design

### 5.1 Chunk structure

* Base block size = 64 bytes.
* Special-case: If total padded length is exactly 64 bytes, chunk size is reduced to 32 bytes to force ≥2 chunks for mixing.

### 5.2 Rounds

Rounds = `2*difficulty + 3`

* **`2*difficulty`**: Ensures outputs for difficulty `N` and `N+1` are completely different, avoiding partial overlaps.
* **`+3`**: Guarantees that flipping a single bit in any chunk produces a fully diffused output, even if the change is in the second-last chunk.

### 5.3 Mixing function

For each round:

* Process chunks from last to first (encryption) or first to last (decryption).
* Hash previous chunk (or wrap-around chunk) + `(round || chunkIndex)` using keyed BLAKE3.
* XOR digest into current chunk.

### 5.4 Key derivation

* `safeKey = BLAKE3.DeriveKey("@UMBRA-v0.0.0-@STDMACE-@MACE-" + context, key || salt)`
* Same `safeKey` used for:

  * Block-mixing PRF in encryption/decryption.
  * Tag generation in AEAD modes (with independent `Reset()`).

---

## 6. Parameters

* **Salt size**: v1 uses 12 bytes.
* **Tag size**: v1 uses 16 bytes.
* **Difficulty**: Tunable integer. CPU cost ≈ `(2*difficulty+3) * (messageLen / chunkSize)` BLAKE3 calls.
* **Chunk size**: 64 bytes (special-case 32 bytes for minimal messages = shorter than 1 full chunk).

---

## 7. References

* [MACE Design](https://github.com/MHSarmadi/MACE)
* [BLAKE3 Specification](https://github.com/BLAKE3-team/BLAKE3-specs)
* NIST SP 800-38D (AEAD guidelines)
